## ams_version=1.0

LibraryModule LocationIQ {
	Prefix: liq;
	Interface: Public_Section;
	Section Public_Section {
		Procedure pr_setAccessToken {
			Arguments: (sp_newAccessToken);
			Body: {
				sp_accessToken := sp_newAccessToken ;
			}
			Comment: "Set the access token to be used by pr_GeoFindCoordinates.";
			StringParameter sp_newAccessToken {
				Property: Input;
			}
		}
		Procedure pr_GeoFindCoordinates {
			Arguments: (address,latitude,longitude,email,url);
			Body: {
				
				block
					_p_returnCode := 1;
					CurrentErrorMessage := "" ;
					pr_workGeoFindCoordinates(address,latitude,longitude);
				onerror _ep_err do
					if CurrentErrorMessage then
						CurrentErrorMessage += "\n" + errh::Message(_ep_err);
					else
						CurrentErrorMessage := errh::Message(_ep_err);
					endif ;
					_p_returnCode := 0;
					errh::MarkAsHandled(_ep_err);
				endblock ;
				
				return _p_returnCode ;
			}
			Comment: {
				"The procedure liq::pr_GeoFindCoordinates can be used to find the latitude/longitude coordinates for a given address.
				The procedure uses the LocationIQ geocoding service, see https://locationiq.com/"
			}
			StringParameter address {
				Property: Input;
				Comment: "A string representing the address for which the latitude and longitude coordinates have to be found.";
			}
			Parameter latitude {
				Property: Output;
				Comment: "A scalar numerical parameter that will contain the latitude coordinate of the specified address upon success.";
			}
			Parameter longitude {
				Property: Output;
				Comment: "A scalar numerical parameter that will contain the longitude coordinate of the specified address upon success.";
			}
			StringParameter email {
				Property: Optional;
				Comment: "Argument ignored, just provided for compatibility.";
			}
			StringParameter url {
				Property: Optional;
				Comment: "Argument ignored, just provided for compatibility.";
			}
			ElementParameter _ep_err {
				Range: errh::PendingErrors;
			}
			Parameter _p_returnCode;
		}
		StringParameter sp_req_address;
		ElementParameter _ep_statusCode {
			Range: dex::HTTPStatusCodes;
		}
		Parameter p_globLat;
		Parameter p_globLon;
		Set s_results {
			Index: i_result;
		}
		ElementParameter ep_cur_rid {
			Range: s_results;
		}
		Set s_placeIds {
			Index: i_placeId;
		}
		ElementParameter ep_cur_pid {
			Range: s_placeIds;
		}
		Parameter p_latitude {
			IndexDomain: (i_result, i_placeId);
		}
		Parameter p_longitude {
			IndexDomain: (i_result, i_placeId);
		}
		ElementParameter _ep_first_res {
			Range: s_results;
		}
		ElementParameter _ep_first_pid {
			Range: s_placeIds;
		}
		StringParameter sp_locationIQ_error_message;
		StringParameter sp_default_access_token {
			Definition: "Please replace by your access token";
		}
		StringParameter sp_accessToken;
		StringParameter sp_reg {
			InitialData: {
				"eu1"
				
				! Alternatives: eu1, us1.
			}
		}
	}
	Section Private_Section {
		Procedure pr_workGeoFindCoordinates {
			Arguments: (address,latitude,longitude);
			Body: {
				! When doing multiple calls to a function, and just one, or a few, calls fail; 
				! it helps to know which one; thus the address is cached for error reporting.
				sp_req_address := address ; ! Used for error reporting.
				
				block ! Encode the arguments of this function, as they are used in the URL for the REST API call:
					_s_ints := elementrange(1,1);
					_sp_str('1') := sp_address ;
					dex::client::QueryMapEncode(
						queryMap    :  _sp_str, 
						queryString :  _sp_query);
				endblock ;
				
				block ! Construct the URL to be used.
					_sp_reg := "eu1" ; ! Alternatives: eu1, us1.
					_sp_url := 
						formatString("https://%s.locationiq.com/v1/search?" , _sp_reg)+
						formatSTring("key=%s&",sp_accessToken)+
						formatString("q=%s&format=json&",_sp_query);
				endblock ;
				
				block ! Construct the request to be made.
					_sp_theRequest := "getLocation" ;
					_ep_callback := 'liq::pr_workGeoFindCoordinatesCallback';
					dex::client::NewRequest(
						theRequest    :  _sp_theRequest, 
						url           :  _sp_url, 
						callback      :  _ep_callback, 
						httpMethod    :  'GET', 
						requestFile   :  "", 
						responseFile  :  sp_libfolder + "/data/getLocation.json", 
						traceFile     :  "", 
						requestOffset :  0, 
						requestSize   :  0);
					dex::client::AddRequestTag(_sp_theRequest, _sp_theRequest); ! Add a tag to the request, such that the wait below doesn't return too early.
				endblock ;
				
				block ! And finally perform the request and await its results.
					dex::client::PerformRequest(_sp_theRequest);
					if (not dex::client::WaitForResponses(5 * 1000,_sp_theRequest)) then
						raise error "timeout" ;
					endif ;
					latitude  := p_globLat ;
					longitude := p_globLon ;
				endblock ;
			}
			StringParameter address {
				Property: Input;
			}
			Parameter latitude {
				Property: Output;
			}
			Parameter longitude {
				Property: Output;
			}
			StringParameter _sp_url;
			StringParameter _sp_reg;
			Set _s_ints {
				SubsetOf: Integers;
				Index: _i_int;
			}
			StringParameter _sp_str {
				IndexDomain: _i_int;
			}
			StringParameter _sp_query;
			StringParameter _sp_theRequest;
			ElementParameter _ep_callback {
				Range: AllProcedures;
				Default: 'dex::client::EmptyCallback';
			}
		}
		Procedure pr_workGeoFindCoordinatesCallback {
			Arguments: (theRequest,statusCode,errorCode);
			Body: {
				if statusCode = 200 then
				
					! All ok, and the response file contains data that can be interpreted according to "Mappings/getLocationJSON.XML"
					dex::ReadFromFile(
						dataFile         :  sp_libfolder + "/data/getLocation.json", 
						mappingName      :  "getLocationJSON", 
						emptyIdentifiers :  0, 
						emptySets        :  0, 
						resetCounters    :  0);
				
					_ep_first_res := first( s_results );
					_ep_first_pid := first( s_placeIds );
					p_globLat := p_latitude(  _ep_first_res, _ep_first_pid );
					p_globLon := p_longitude( _ep_first_res, _ep_first_pid );
				
				else
				
					! Handle error.
					if statusCode = 0 then
						! Message from CURL.
						dex::client::GetErrorMessage(errorCode,_sp_curl_message);
						_sp_error_message := formatString("Error obtaining GPS coordinates from LocationIQ for \"%s\", CURL details: \"%s\"", 
							sp_req_address, _sp_curl_message);
					else
						! Message from Server
						_ep_statusCode := StringToElement(dex::HTTPStatusCodes, formatString("%i", statusCode),create:0);
						if _ep_statusCode then
							! Not ok, and the response file contains data that can be interpreted according to "Mappings/errorJSON.XML"
							dex::ReadFromFile(
								dataFile         :  sp_libfolder + "/data/getLocation.json", 
								mappingName      :  "errorJSON", 
								emptyIdentifiers :  0, 
								emptySets        :  0, 
								resetCounters    :  0);
							_sp_error_message := formatString("Error obtaining GPS coordinates from LocationIQ for \"%s\", status code %e: \"%s\", error code: %i, LocationIQ feedback: \"%s\"", 
								sp_req_address, _ep_statusCode, dex::HTTPStatusCodeDescription(_ep_statusCode), errorCode, sp_locationIQ_error_message );
						else
							_sp_error_message := formatString("Error obtaining GPS coordinates from LocationIQ for \"%s\", unknown status code: %i, error code: %i", 
								sp_req_address, statusCode, errorCode );
						endif ;
					endif ;
					raise error _sp_error_message ;
				endif ;
			}
			StringParameter theRequest {
				Property: Input;
			}
			Parameter statusCode {
				Property: Input;
			}
			Parameter errorCode {
				Property: Input;
			}
			StringParameter _sp_error_message;
			StringParameter _sp_curl_message;
			StringParameter _sp_server_message;
		}
		Section Lib_start_stop {
			StringParameter sp_libfolder;
			Procedure LibraryInitialization {
				Comment: "Add initialization statements here that do not require any other library being initialized already.";
			}
			Procedure PostLibraryInitialization {
				Body: {
					block ! Initialize the access token used, whereby the default access token is a question to provide one.
						sp_accessToken := sp_default_access_token ;
						! For testing purposes it is convenient to store your access token in a file next to your AIMMS project (but not in!)
						_sp_access_token_file := "..\\api-init\\LocationIQ.txt" ;
						if FileExists( _sp_access_token_file ) then
							read from file _sp_access_token_file ;
						endif ;
					endblock ;
					
					block ! Ensure that additional files stored in the library can be accessed easily.
						DirectoryOfLibraryProject(
							libraryname   :  "LocationIQ", 
							directoryname :  sp_libfolder);
						dex::ReadMappings(
							startPath :  sp_libfolder, 
							subFolder :  "", 
							recursive :  1);
						if not  DirectoryExists( sp_libfolder + "/data" ) then
							DirectoryCreate( sp_libfolder + "/data" );
						endif ;
					endblock ;
					
					block ! Provide end user friendly names for identifiers of this library used in the WebUI.
						webui::IdentifierElementText(IndexIdentifiers) :=$ data {
							'liq::sp_accessToken' : "Your access token" 
						} ;
					endblock ;
				}
				Comment: {
					"Add initialization statements here that require another library to be initialized already,
					or add statements that require the Data Management module to be initialized."
				}
				StringParameter _sp_access_token_file;
			}
			Procedure PreLibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that require all other libraries to be still alive.
					Return 1 if you allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence."
				}
			}
			Procedure LibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that do not require other libraries to be still alive.
					Return 1 to allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence.
					It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
				}
			}
		}
	}
}
